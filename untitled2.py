# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ReTVOD6SPhDBq_kF9-mXtdWKPXpiTzyq
"""

import numpy as np
import matplotlib.pyplot as plt

# Bus types for clarity
PQ = 1
PV = 2
SLACK = 3

def build_Ybus(bus_data, line_data):
    nb = len(bus_data)
    Ybus = np.zeros((nb, nb), dtype=complex)
    for line in line_data:
        f, t, R, X, B = line
        z = complex(R, X)
        y = 1 / z
        b = complex(0, B / 2)

        f -= 1  # zero-based indexing
        t -= 1
        Ybus[f, f] += y + b
        Ybus[t, t] += y + b
        Ybus[f, t] -= y
        Ybus[t, f] -= y
    return Ybus

def gauss_seidel_power_flow(bus_data, line_data, max_iter=100, tol=1e-6):
    nb = len(bus_data)
    Ybus = build_Ybus(bus_data, line_data)

    # Initial voltage guess
    V = np.array([bus[4] * np.exp(1j * np.radians(bus[6])) for bus in bus_data])
    bus_types = [bus[1] for bus in bus_data]

    P_spec = np.array([bus[2] for bus in bus_data])
    Q_spec = np.array([bus[3] for bus in bus_data])

    for iteration in range(max_iter):
        V_prev = V.copy()
        for i in range(nb):
            if bus_types[i] == SLACK:
                continue  # Slack bus voltage fixed

            Yi = Ybus[i, :]
            sumYV = np.dot(Yi, V) - Yi[i]*V[i]

            # Calculate power mismatch
            S = complex(P_spec[i], Q_spec[i])
            if bus_types[i] == PV:
                # For PV bus, Q is unknown - estimate it from current voltages
                Q_calc = -np.imag(V[i] * np.conj(sumYV))
                Q_spec[i] = Q_calc
                S = complex(P_spec[i], Q_calc)

            V[i] = (1 / Yi[i]) * (np.conj(S) / np.conj(V[i])) - sumYV
            if bus_types[i] == PV:
                V[i] = bus_data[i][4] * np.exp(1j * np.angle(V[i]))
        max_diff = np.max(np.abs(V - V_prev))
        print(f"Iter {iteration+1}: max voltage change = {max_diff:.8f}")
        if max_diff < tol:
            break
    else:
        print("Warning: Gauss-Seidel did not converge within max iterations")

    return V, Ybus

def calculate_power_losses(V, Ybus):
    I = Ybus @ V
    S = V * np.conj(I)
    total_injected_power = np.sum(S).real
    total_load_power = -np.sum([bus[2] for bus in bus_data if bus[2] < 0])
    losses = total_injected_power - total_load_power
    return losses, total_load_power
def calculate_efficiency(losses, load_power):
    if load_power <= 0:
        return 1.0
    return load_power / (load_power + losses)
if __name__ == "__main__":
    bus_data = [
        [1, SLACK, 0, 0, 1.06, 1.06, 0],
        [2, PV, 0.5, 0, 1.045, 1.0, 0],
        [3, PQ, -0.6, -0.3, 1.0, 1.0, 0]
    ]
    line_data = [
        [1, 2, 0.02, 0.06, 0.03],
        [1, 3, 0.08, 0.24, 0.025],
        [2, 3, 0.06, 0.18, 0.02]
    ]
    V, Ybus = gauss_seidel_power_flow(bus_data, line_data)
    print("\nBus Voltages:")
    for i, v in enumerate(V):
        print(f"Bus {i+1}: {abs(v):.4f} ∠ {np.degrees(np.angle(v)):.2f}°")
    losses, load_power = calculate_power_losses(V, Ybus)
    print(f"\nTotal Power Losses: {losses:.4f} p.u.")
    efficiency = calculate_efficiency(losses, load_power)
    print(f"Efficiency: {efficiency * 100:.2f}%")
    plt.bar(range(1, len(V) + 1), np.abs(V))
    plt.xlabel('Bus Number')
    plt.ylabel('Voltage Magnitude (p.u.)')
    plt.title('Bus Voltage Magnitudes - Gauss-Seidel')
    plt.grid(True)
    plt.show()